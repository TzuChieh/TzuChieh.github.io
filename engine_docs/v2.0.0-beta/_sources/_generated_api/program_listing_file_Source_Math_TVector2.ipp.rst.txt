
.. _program_listing_file_Source_Math_TVector2.ipp:

Program Listing for File TVector2.ipp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file_Source_Math_TVector2.ipp>` (``Source\Math\TVector2.ipp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include "Math/TVector2.h"
   #include "Math/math.h"
   #include "Common/assertion.h"
   #include "Utility/utility.h"
   
   #include <cmath>
   #include <algorithm>
   #include <type_traits>
   #include <array>
   
   namespace ph::math
   {
   
   template<typename T>
   inline TVector2<T>::TVector2(const T vx, const T vy) : 
       Base(std::array<T, 2>{vx, vy})
   {}
   
   template<typename T>
   template<typename U>
   inline TVector2<T>::TVector2(const TVector2<U>& other) : 
       TVector2(static_cast<T>(other[0]), static_cast<T>(other[1]))
   {}
   
   template<typename T>
   template<typename U>
   inline TVector2<U> TVector2<T>::losslessCast() const
   {
       return TVector2<U>(
           lossless_cast<U>(m[0]),
           lossless_cast<U>(m[1]));
   }
   
   template<typename T>
   inline T& TVector2<T>::x()
   {
       return m[0];
   }
   
   template<typename T>
   inline T& TVector2<T>::y()
   {
       return m[1];
   }
   
   template<typename T>
   inline const T& TVector2<T>::x() const
   {
       return m[0];
   }
   
   template<typename T>
   inline const T& TVector2<T>::y() const
   {
       return m[1];
   }
   
   template<typename T>
   inline T& TVector2<T>::u()
   {
       return m[0];
   }
   
   template<typename T>
   inline T& TVector2<T>::v()
   {
       return m[1];
   }
   
   template<typename T>
   inline const T& TVector2<T>::u() const
   {
       return m[0];
   }
   
   template<typename T>
   inline const T& TVector2<T>::v() const
   {
       return m[1];
   }
   
   }// end namespace ph::math
