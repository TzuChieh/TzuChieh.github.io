
.. _program_listing_file_Source_Utility_Concurrent_InitiallyPausedThread.h:

Program Listing for File InitiallyPausedThread.h
================================================

|exhale_lsh| :ref:`Return to documentation for file <file_Source_Utility_Concurrent_InitiallyPausedThread.h>` (``Source\Utility\Concurrent\InitiallyPausedThread.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include "Utility/IMoveOnly.h"
   #include "Common/debug.h"
   #include "Common/logging.h"
   #include "Utility/exception.h"
   
   #include <thread>
   #include <future>
   #include <functional>
   #include <utility>
   
   namespace ph
   {
   
   class InitiallyPausedThread final : private IMoveOnly
   {
   public:
       InitiallyPausedThread();
   
       inline InitiallyPausedThread(InitiallyPausedThread&& other) = default;
   
       template<typename Func, typename... Args>
       explicit InitiallyPausedThread(Func&& func, Args&&... args);
   
       ~InitiallyPausedThread();
   
       void start();
   
       void join();
   
       bool hasStarted() const;
   
       bool hasJoined() const;
   
       std::thread::id getId() const;
   
       inline InitiallyPausedThread& operator = (InitiallyPausedThread&& rhs) = default;
   
   private:
       void setPromisedValue(bool value);
       bool isEmptyThread() const;
   
       std::thread        m_thread;
       std::promise<bool> m_startPromise;
       bool               m_hasStarted;
       bool               m_hasJoined;
   };
   
   template<typename Func, typename... Args>
   inline InitiallyPausedThread::InitiallyPausedThread(Func&& func, Args&&... args)
       : InitiallyPausedThread()
   {
       m_thread = std::thread(
           [startFuture = m_startPromise.get_future(),
            func = std::bind(std::forward<Func>(func), std::forward<Args>(args)...)]
           () mutable
           {
               try
               {
                   if(startFuture.get())
                   {
                       func();
                   }
               }
               catch(const Exception& e)
               {
                   PH_DEFAULT_LOG_ERROR("[InitiallyPausedThread] unhandled exception thrown: {}",
                       e.what());
   
                   PH_DEBUG_BREAK();
               }
           });
   }
   
   inline bool InitiallyPausedThread::hasStarted() const
   {
       return m_hasStarted;
   }
   
   inline bool InitiallyPausedThread::hasJoined() const
   {
       return m_hasJoined;
   }
   
   inline std::thread::id InitiallyPausedThread::getId() const
   {
       return m_thread.get_id();
   }
   
   inline bool InitiallyPausedThread::isEmptyThread() const
   {
       return m_thread.get_id() == std::thread::id();
   }
   
   }// end namespace ph
