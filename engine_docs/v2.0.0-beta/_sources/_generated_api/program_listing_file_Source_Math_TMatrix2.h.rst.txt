
.. _program_listing_file_Source_Math_TMatrix2.h:

Program Listing for File TMatrix2.h
===================================

|exhale_lsh| :ref:`Return to documentation for file <file_Source_Math_TMatrix2.h>` (``Source\Math\TMatrix2.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include "Math/math_fwd.h"
   
   #include <cstddef>
   #include <array>
   #include <string>
   
   namespace ph::math
   {
   
   template<typename T>
   class TMatrix2 final
   {
   public:
       static TMatrix2 makeIdentity();
   
   public:
       using Elements = std::array<std::array<T, 2>, 2>;
   
       Elements m;
   
       inline TMatrix2() = default;
       explicit TMatrix2(T value);
       TMatrix2(T m00, T m01, T m10, T m11);
       TMatrix2(const TVector2<T>& m00m01, const TVector2<T>& m10m11);
       inline TMatrix2(const TMatrix2& other) = default;
   
       template<typename U>
       explicit TMatrix2(const TMatrix2<U>& other);
   
       TMatrix2& initIdentity();
       TMatrix2 mul(const TMatrix2& rhs) const;
       TMatrix2 mul(T value) const;
       void mul(const TMatrix2& rhs, TMatrix2* out_result) const;
       TMatrix2& mulLocal(T value);
       TMatrix2 inverse() const;
       T determinant() const;
   
       // TODO: make solve() methods accepts all "subscriptable" types to (potentially) 
       // improve performance & less code duplications
   
       bool solve(
           const std::array<T, 2>& b,
           std::array<T, 2>*       out_x) const;
   
       bool solve(
           const TVector2<T>& b,
           TVector2<T>*       out_x) const;
   
       template<std::size_t N>
       bool solve(
           const std::array<std::array<T, 2>, N>& bs, 
           std::array<std::array<T, 2>, N>*       out_xs) const;
   
       std::string toString() const;
   };
   
   }// end namespace ph::math
   
   #include "Math/TMatrix2.ipp"
