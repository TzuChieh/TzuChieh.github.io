
.. _program_listing_file_Source_Utility_Concurrent_PeriodicSingleThreadExecutor.h:

Program Listing for File PeriodicSingleThreadExecutor.h
=======================================================

|exhale_lsh| :ref:`Return to documentation for file <file_Source_Utility_Concurrent_PeriodicSingleThreadExecutor.h>` (``Source\Utility\Concurrent\PeriodicSingleThreadExecutor.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include "Common/config.h"
   #include "Common/primitive_type.h"
   
   #include <atomic>
   #include <vector>
   #include <functional>
   #include <thread>
   #include <mutex>
   #include <condition_variable>
   
   namespace ph
   {
   
   class PeriodicSingleThreadExecutor final
   {
   public:
       using Work = std::function<void()>;
   
   public:
       explicit PeriodicSingleThreadExecutor(uint64 periodMs);
   
       ~PeriodicSingleThreadExecutor();
   
       void addWork(const Work& work);
       void addWork(Work&& work);
   
       void setPeriodMs(uint64 periodMs);
   
       void pause();
   
       void resume();
   
       void requestTermination();
   
   private:
       void asyncProcessWork();
   
       bool isWorkerThread() const;
   
   
   #ifdef PH_ENSURE_LOCKFREE_ALGORITHMS_ARE_LOCKLESS
       static_assert(std::atomic<uint64>::is_always_lock_free);
   #endif
   
       std::thread             m_worker;
       std::vector<Work>       m_works;
       std::mutex              m_executorMutex;
       std::condition_variable m_workerCv;
       bool                    m_isWorking;
       bool                    m_isTerminationRequested;
       std::atomic<uint64>     m_periodMs;
   };
   
   // In-header Implementations:
   
   inline void PeriodicSingleThreadExecutor::setPeriodMs(const uint64 periodMs)
   {
       m_periodMs.store(periodMs, std::memory_order_relaxed);
   }
   
   inline bool PeriodicSingleThreadExecutor::isWorkerThread() const
   {
       return std::this_thread::get_id() == m_worker.get_id();
   }
   
   }// end namespace ph
