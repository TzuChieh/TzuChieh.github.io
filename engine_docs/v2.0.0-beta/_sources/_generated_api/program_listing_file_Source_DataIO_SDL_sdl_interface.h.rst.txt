
.. _program_listing_file_Source_DataIO_SDL_sdl_interface.h:

Program Listing for File sdl_interface.h
========================================

|exhale_lsh| :ref:`Return to documentation for file <file_Source_DataIO_SDL_sdl_interface.h>` (``Source\DataIO\SDL\sdl_interface.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   // Base types
   #include "DataIO/SDL/Introspect/SdlClass.h"
   #include "DataIO/SDL/Introspect/SdlStruct.h"
   #include "DataIO/SDL/Introspect/SdlFunction.h"
   #include "DataIO/SDL/Introspect/SdlEnum.h"
   
   // Enum types
   #include "DataIO/SDL/Introspect/TBasicSdlEnum.h"
   #include "DataIO/SDL/Introspect/TSdlEnum.h"
   
   // Owner types
   #include "DataIO/SDL/Introspect/TOwnerSdlClass.h"
   #include "DataIO/SDL/Introspect/TOwnerSdlStruct.h"
   
   // Field types
   #include "DataIO/SDL/Introspect/TSdlBool.h"
   #include "DataIO/SDL/Introspect/TSdlInteger.h"
   #include "DataIO/SDL/Introspect/TSdlReal.h"
   #include "DataIO/SDL/Introspect/TSdlString.h"
   #include "DataIO/SDL/Introspect/TSdlVector2.h"
   #include "DataIO/SDL/Introspect/TSdlVector3.h"
   #include "DataIO/SDL/Introspect/TSdlQuaternion.h"
   #include "DataIO/SDL/Introspect/TSdlRealArray.h"
   #include "DataIO/SDL/Introspect/TSdlVector3Array.h"
   #include "DataIO/SDL/Introspect/TSdlReference.h"
   #include "DataIO/SDL/Introspect/TSdlEnumField.h"
   #include "DataIO/SDL/Introspect/TSdlPath.h"
   
   // Function types
   #include "DataIO/SDL/Introspect/TSdlMethod.h"
   
   #include "DataIO/SDL/ISdlResource.h"
   
   #include <type_traits>
   
   // TODO: need traits helper to verify a sdl class/struct also contains the required macro
   
   #define PH_DEFINE_SDL_CLASS(...)/* variadic args for template types that contain commas */\
       \
       using ClassType = __VA_ARGS__;\
       using OwnerType = typename ClassType::OwnerType;\
       \
       /* Dummy type so we know the macro has been called. */\
       using SdlClassDefinitionMarker = void;\
       \
       inline static const ClassType* getSdlClass()\
       {\
           static_assert(std::is_base_of_v<::ph::ISdlResource, OwnerType>,\
               "PH_DEFINE_SDL_CLASS() can only be defined for SDL resource.");\
           static_assert(std::is_base_of_v<::ph::SdlClass, ClassType>,\
               "PH_DEFINE_SDL_CLASS() must return a class derived from SdlClass.");\
           \
           static const ClassType sdlClass = internal_sdl_class_impl();\
           return &sdlClass;\
       }\
       \
       inline const ::ph::SdlClass* getDynamicSdlClass() const override\
       {\
           return getSdlClass();\
       }\
       \
       inline static ClassType internal_sdl_class_impl()
   
   #define PH_DEFINE_SDL_STRUCT(...)/* variadic args for template types that contain commas */\
       \
       using StructType = __VA_ARGS__;\
       using OwnerType  = typename StructType::OwnerType;\
       \
       /* Dummy type so we know the macro has been called. */\
       using SdlStructDefinitionMarker = void;\
       \
       inline static const StructType* getSdlStruct()\
       {\
           static_assert(std::is_base_of_v<::ph::SdlStruct, StructType>,\
               "PH_DEFINE_SDL_STRUCT() must return a struct derived from SdlStruct.");\
           \
           static const StructType sdlStruct = internal_sdl_struct_impl();\
           return &sdlStruct;\
       }\
       \
       inline static StructType internal_sdl_struct_impl()
   
   #define PH_DEFINE_SDL_FUNCTION(...)/* variadic args for template types that contain commas */\
       \
       using FunctionType = __VA_ARGS__;\
       using OwnerType    = typename FunctionType::OwnerType;\
       \
       /* Dummy type so we know the macro has been called. */\
       using SdlFunctionDefinitionMarker = void;\
       \
       inline static const FunctionType* getSdlFunction()\
       {\
           static_assert(std::is_base_of_v<::ph::SdlFunction, FunctionType>,\
               "PH_DEFINE_SDL_FUNCTION() must return a function derived from SdlFunction.");\
           \
           static const FunctionType sdlFunction = internal_sdl_function_impl();\
           return &sdlFunction;\
       }\
       \
       inline static FunctionType internal_sdl_function_impl()
   
   #define PH_DEFINE_SDL_ENUM(...)/* variadic args for template types that contain commas */\
       template<>\
       class TSdlEnum<typename __VA_ARGS__::EnumType> final\
       {\
       private:\
       \
           using SdlEnumType = __VA_ARGS__;\
           using EnumType    = typename SdlEnumType::EnumType;\
       \
           static_assert(std::is_enum_v<EnumType>,\
               "EnumType must be an enum. Currently it is not.");\
       \
       public:\
           inline EnumType operator [] (const std::string_view entryName) const\
           {\
               const ::ph::SdlEnum::TEntry<EnumType> entry = getSdlEnum()->getTypedEntry(entryName);\
               return entry.value;\
           }\
       \
           inline std::string_view operator [] (const EnumType entryValue) const\
           {\
               const ::ph::SdlEnum::TEntry<EnumType> entry = getSdlEnum()->getTypedEntry(entryValue);\
               return entry.name;\
           }\
       \
           inline static const SdlEnumType* getSdlEnum()\
           {\
               static_assert(std::is_base_of_v<::ph::SdlEnum, SdlEnumType>,\
                   "PH_DEFINE_SDL_ENUM() must return an enum derived from SdlEnum.");\
               \
               static const SdlEnumType sdlEnum = internal_sdl_enum_impl();\
               return &sdlEnum;\
           }\
       \
       private:\
           static SdlEnumType internal_sdl_enum_impl();\
       };\
       \
       /* In-header Implementations: */\
       \
       inline __VA_ARGS__ TSdlEnum<typename __VA_ARGS__::EnumType>::internal_sdl_enum_impl()
