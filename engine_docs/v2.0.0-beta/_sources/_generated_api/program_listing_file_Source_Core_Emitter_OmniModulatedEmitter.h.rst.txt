
.. _program_listing_file_Source_Core_Emitter_OmniModulatedEmitter.h:

Program Listing for File OmniModulatedEmitter.h
===============================================

|exhale_lsh| :ref:`Return to documentation for file <file_Source_Core_Emitter_OmniModulatedEmitter.h>` (``Source\Core\Emitter\OmniModulatedEmitter.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include "Core/Emitter/Emitter.h"
   #include "Common/primitive_type.h"
   #include "Core/Texture/TTexture.h"
   #include "Core/Intersectable/UvwMapper/SphericalMapper.h"
   
   #include <memory>
   
   namespace ph
   {
   
   // TODO: importance sampling based on filter values
   
   class OmniModulatedEmitter final : public Emitter
   {
   public:
       OmniModulatedEmitter(std::unique_ptr<Emitter> source);
   
       void evalEmittedRadiance(const SurfaceHit& X, math::Spectrum* out_radiance) const override;
       void genDirectSample(DirectEnergySampleQuery& query, SampleFlow& sampleFlow) const override;
   
       // FIXME: ray time
       void emitRay(SampleFlow& sampleFlow, Ray* out_ray, math::Spectrum* out_Le, math::Vector3R* out_eN, real* out_pdfA, real* out_pdfW) const override;
   
       real calcDirectSamplePdfW(const SurfaceHit& emitPos, const math::Vector3R& targetPos) const override;
       real calcRadiantFluxApprox() const override;
   
       void setFilter(const std::shared_ptr<TTexture<math::Spectrum>>& filter);
   
   private:
       std::unique_ptr<Emitter>                  m_source;
       std::shared_ptr<TTexture<math::Spectrum>> m_filter;
       SphericalMapper                           m_dirToUv;
   };
   
   }// end namespace ph
