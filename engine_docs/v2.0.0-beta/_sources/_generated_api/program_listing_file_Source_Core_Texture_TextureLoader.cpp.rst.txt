
.. _program_listing_file_Source_Core_Texture_TextureLoader.cpp:

Program Listing for File TextureLoader.cpp
==========================================

|exhale_lsh| :ref:`Return to documentation for file <file_Source_Core_Texture_TextureLoader.cpp>` (``Source\Core\Texture\TextureLoader.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #include "Core/Texture/TextureLoader.h"
   #include "Core/Texture/LdrRgbTexture2D.h"
   #include "Math/Random.h"
   
   #include "Common/ThirdParty/lib_stb.h"
   
   #include <iostream>
   
   namespace ph
   {
   
   TextureLoader::TextureLoader()
   {
   
   }
   
   bool TextureLoader::load(const std::string& fullFilename, RgbPixelTexture* const out_rgbPixelTexture)
   {
       //std::cout << "loading image <" << fullFilename << ">" << std::endl;
   
       //int widthPx;
       //int heightPx;
       //int numComponents;
   
       //stbi_set_flip_vertically_on_load(true);
   
       //stbi_uc* stbImageData = stbi_load(fullFilename.c_str(), &widthPx, &heightPx, &numComponents, 0);
   
       //if(stbImageData == NULL)
       //{
       //  std::cerr << "warning: at TextureLoader::load(), file <" << fullFilename << "> loading failed" << std::endl;
       //  std::cerr << "(message: " << stbi_failure_reason() << ")" << std::endl;
       //  return false;
       //}
   
       //if(numComponents != 3)
       //{
       //  std::cerr << "warning: at TextureLoader::load(), " 
       //            << "texture <" << fullFilename << "> #comp. != 3, unsupported" << std::endl;
       //  return false;
       //}
   
       //const uint32 dataSize = widthPx * heightPx * numComponents;
       //std::vector<real> pixelData(static_cast<std::size_t>(dataSize), 0.0_r);
       //for(uint32 i = 0; i < dataSize; i += 3)
       //{
       //  const Vector3R sRgbPixel(stbImageData[i + 0] / 255.0_r, 
       //                           stbImageData[i + 1] / 255.0_r, 
       //                           stbImageData[i + 2] / 255.0_r);
   
       //  const Vector3R linearRgb = ColorSpace::sRgbToLinearRgb(sRgbPixel);
   
       //  pixelData[i + 0] = linearRgb.x;
       //  pixelData[i + 1] = linearRgb.y;
       //  pixelData[i + 2] = linearRgb.z;
       //}
   
       //stbi_image_free(stbImageData);
   
       //out_rgbPixelTexture->resize(static_cast<uint32>(widthPx), static_cast<uint32>(heightPx));
       //out_rgbPixelTexture->setPixels(0, 0, 
       //                               static_cast<uint32>(widthPx), static_cast<uint32>(heightPx), 
       //                               pixelData.data());
   
       //return true;
   
       return false;
   }
   
   }// end namespace ph
