
.. _program_listing_file_Source_Utility_TSortedMap.h:

Program Listing for File TSortedMap.h
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file_Source_Utility_TSortedMap.h>` (``Source\Utility\TSortedMap.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include "Utility/TSortedVector.h"
   #include "Utility/utility.h"
   
   #include <concepts>
   #include <vector>
   #include <optional>
   #include <cstddef>
   #include <concepts>
   #include <functional>
   #include <utility>
   
   namespace ph
   {
   
   template<typename KeyType, typename ValueType, typename IsLess = std::less<KeyType>>
   class TSortedMap final
   {
   public:
       inline TSortedMap() requires std::default_initializable<IsLess>
           : TSortedMap(0, IsLess{})
       {}
   
       inline explicit TSortedMap(const std::size_t initialCapacity) requires std::default_initializable<IsLess>
           : TSortedMap(initialCapacity, IsLess{})
       {}
   
       TSortedMap(std::size_t initialCapacity, IsLess isLess);
   
       std::size_t map(KeyType key, ValueType value);
   
       std::optional<std::size_t> mapUnique(KeyType key, ValueType value);
   
       bool unmap(const KeyType& key);
   
       bool unmapValues(const KeyType& key);
   
       void unmapByIndex(std::size_t valueIndex);
   
       const ValueType* getValue(const KeyType& key) const;
       inline decltype(auto) getValue(const KeyType& key) { return mutable_cast(std::as_const(*this).getValue(key)); }
   
       const ValueType* getValue(const KeyType& key, std::size_t ithValue) const;
       inline decltype(auto) getValue(const KeyType& key, std::size_t ithValue) { return mutable_cast(std::as_const(*this).getValue(key, ithValue)); }
   
       const ValueType& get(std::size_t valueIndex) const;
       ValueType& get(std::size_t valueIndex);
   
       std::pair<const KeyType&, const ValueType&> getKeyAndValue(std::size_t valueIndex) const;
       std::pair<const KeyType&, ValueType&> getKeyAndValue(std::size_t valueIndex);
   
       std::size_t numValues(const KeyType& key) const;
   
       std::size_t size() const;
   
       bool isEmpty() const;
   
       typename std::vector<ValueType>::const_iterator begin() const noexcept;
       typename std::vector<ValueType>::const_iterator end() const noexcept;
   
   private:
       TSortedVector<KeyType> m_keys;
       std::vector<ValueType> m_values;
   };
   
   }// end namespace ph
   
   #include "Utility/TSortedMap.ipp"
