
.. _program_listing_file_Source_Utility_MemoryArena.h:

Program Listing for File MemoryArena.h
======================================

|exhale_lsh| :ref:`Return to documentation for file <file_Source_Utility_MemoryArena.h>` (``Source\Utility\MemoryArena.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include "Common/memory.h"
   #include "Common/primitive_type.h"
   #include "Utility/IMoveOnly.h"
   #include "Utility/TFunction.h"
   
   #include <cstddef>
   #include <vector>
   #include <span>
   #include <utility>
   #include <memory>
   #include <type_traits>
   
   namespace ph
   {
   
   class MemoryArena final : private IMoveOnly
   {
   public:
       MemoryArena();
   
       MemoryArena(std::size_t blockSizeInBytes, std::size_t numDefaultBlocks);
       
       inline MemoryArena(MemoryArena&& other) = default;
   
       ~MemoryArena();
   
       std::byte* allocRaw(std::size_t numBytes, std::size_t alignmentInBytes = alignof(std::max_align_t));
   
       void clear();
   
       std::size_t numUsedBytes() const;
       std::size_t numAllocatedBytes() const;
       std::size_t getBlockSizeInBytes() const;
       std::size_t numAllocatedBlocks() const;
   
       inline MemoryArena& operator = (MemoryArena&& rhs) = default;
   
       template<typename T>
       inline T* alloc()
           requires std::is_trivially_destructible_v<T>
       {
           return reinterpret_cast<T*>(allocRaw(sizeof(T), alignof(T)));
       }
   
       template<typename T>
       inline std::span<T> allocArray(const std::size_t arraySize)
           requires std::is_trivially_destructible_v<T>
       {
           return std::span<T>(
               reinterpret_cast<T*>(allocRaw(sizeof(T) * arraySize, alignof(T))), 
               arraySize);
       }
   
       template<typename T, typename... Args>
       inline T* make(Args&&... args)
       {
           if constexpr(std::is_trivially_destructible_v<T>)
           {
               return std::construct_at(alloc<T>(), std::forward<Args>(args)...);
           }
           else
           {
               T* const objPtr = std::construct_at(
                   reinterpret_cast<T*>(allocRaw(sizeof(T), alignof(T))), 
                   std::forward<Args>(args)...);
   
               // Record the dtor so we can call it later (on clear)
               m_dtorCallers.push_back(
                   [objPtr]()
                   {
                       objPtr->~T();
                   });
   
               return objPtr;
           }
       }
   
   private:
       std::vector<TAlignedMemoryUniquePtr<std::byte>> m_blocks;
   
       std::size_t m_blockSizeInBytes;
       std::size_t m_currentBlockIdx;
       std::byte*  m_blockPtr;
       std::size_t m_remainingBytesInBlock;
       std::size_t m_numUsedBytes;
   
       // Destructors of non-trivially-copyable objects. Simply specify `MIN_SIZE_HINT = 0` for 
       // smallest possible `TFunction`; increase it if compilation failed (investigate first).
       std::vector<TFunction<void(void), 0>> m_dtorCallers;
   };
   
   inline std::size_t MemoryArena::numUsedBytes() const
   {
       return m_numUsedBytes;
   }
   
   inline std::size_t MemoryArena::numAllocatedBytes() const
   {
       return getBlockSizeInBytes() * numAllocatedBlocks();
   }
   
   inline std::size_t MemoryArena::getBlockSizeInBytes() const
   {
       return m_blockSizeInBytes;
   }
   
   inline std::size_t MemoryArena::numAllocatedBlocks() const
   {
       return m_blocks.size();
   }
   
   }// end namespace ph
