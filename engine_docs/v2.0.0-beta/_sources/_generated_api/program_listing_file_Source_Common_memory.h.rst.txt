
.. _program_listing_file_Source_Common_memory.h:

Program Listing for File memory.h
=================================

|exhale_lsh| :ref:`Return to documentation for file <file_Source_Common_memory.h>` (``Source\Common\memory.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include "Common/os.h"
   #include "Common/assertion.h"
   #include "Common/math_basics.h"
   
   #if defined(PH_OPERATING_SYSTEM_IS_WINDOWS)
   
   #include <malloc.h>
   #include <crtdbg.h>
   
   #else
   
   #include <cstdlib>
   
   #endif
   
   #include <cstddef>
   #include <bit>
   #include <memory>
   
   namespace ph
   {
   
   namespace detail
   {
   
   [[nodiscard]]
   inline void* allocate_aligned_memory(const std::size_t numBytes, const std::size_t alignmentInBytes)
   {
       // Alignment must be an integer power of 2.
       PH_ASSERT(math::is_power_of_2(alignmentInBytes));
   
       // Alignment must be a multiple of `sizeof(void*)`.
       PH_ASSERT_EQ(alignmentInBytes % sizeof(void*), 0);
   
       // Allocation size must be an integer multiple of alignment.
       // (here `alignmentInBytes` is guaranteed to be > 0 by the previous assertion)
       PH_ASSERT(numBytes % alignmentInBytes == 0);
   
       PH_ASSERT_GT(numBytes, 0);
   
   #if defined(PH_OPERATING_SYSTEM_IS_WINDOWS)
   
       // Reduced to a call to `_aligned_malloc` when `_DEBUG` is not defined.
       // See https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/aligned-malloc-dbg?view=msvc-170
       return _aligned_malloc_dbg(numBytes, alignmentInBytes, __FILE__, __LINE__);
   
   #else
   
       return std::aligned_alloc(alignmentInBytes, numBytes);
   
   #endif
   }
   
   inline void free_aligned_memory(void* const ptr)
   {
   #if defined(PH_OPERATING_SYSTEM_IS_WINDOWS)
   
       // Reduced to a call to `_aligned_free` when `_DEBUG` is not defined.
       // See https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/aligned-free-dbg?view=msvc-170
       _aligned_free_dbg(ptr);
   
   #else
   
       std::free(ptr);
   
   #endif
   }
   
   struct AlignedMemoryDeleter
   {
       inline void operator () (void* const ptr) const
       {
           free_aligned_memory(ptr);
       }
   };
   
   }// end namespace detail
   
   template<typename T>
   using TAlignedMemoryUniquePtr = std::unique_ptr<T, detail::AlignedMemoryDeleter>;
   
   // Note that `detail::AlignedMemoryDeleter` is for empty base optimization on `std::unique_ptr`, 
   // see https://stackoverflow.com/questions/42715492/stdunique-ptr-and-custom-deleters.
   // This would reduce the size of the resulting `unique_ptr` to the size of a single pointer.
   // Reference: https://stackoverflow.com/questions/45341371/memory-efficient-custom-deleter-for-stdunique-ptr
   // 
   // The following test will ensure this is true:
   static_assert(sizeof(TAlignedMemoryUniquePtr<void>) == sizeof(void*));
   
   template<typename T = void>
   inline auto make_aligned_memory(const std::size_t numBytes, const std::size_t alignmentInBytes)
       -> TAlignedMemoryUniquePtr<T>
   {
       void* const ptr = detail::allocate_aligned_memory(numBytes, alignmentInBytes);
   
       return ptr != nullptr
           ? TAlignedMemoryUniquePtr<T>(static_cast<T*>(ptr))
           : nullptr;
   }
   
   }// end namespace ph
