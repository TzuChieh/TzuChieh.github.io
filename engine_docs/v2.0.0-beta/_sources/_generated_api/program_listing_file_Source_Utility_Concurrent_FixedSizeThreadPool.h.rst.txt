
.. _program_listing_file_Source_Utility_Concurrent_FixedSizeThreadPool.h:

Program Listing for File FixedSizeThreadPool.h
==============================================

|exhale_lsh| :ref:`Return to documentation for file <file_Source_Utility_Concurrent_FixedSizeThreadPool.h>` (``Source\Utility\Concurrent\FixedSizeThreadPool.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <cstddef>
   #include <vector>
   #include <thread>
   #include <mutex>
   #include <condition_variable>
   #include <queue>
   #include <functional>
   
   namespace ph
   {
   
   class FixedSizeThreadPool final
   {
   public:
       using Work = std::function<void()>;
   
   public:
       explicit FixedSizeThreadPool(std::size_t numWorkers);
   
       ~FixedSizeThreadPool();
   
       void queueWork(const Work& work);
       void queueWork(Work&& work);
   
       void waitAllWorks();
   
       void requestTermination();
   
       std::size_t numWorkers() const;
   
   private:
       void asyncProcessWork();
   
       bool isWorkerThread() const;
   
       std::vector<std::thread> m_workers;
       std::queue<Work>         m_works;
       std::mutex               m_poolMutex;
       std::condition_variable  m_workersCv;
       std::condition_variable  m_allWorksDoneCv;
       bool                     m_isTerminationRequested;
       std::size_t              m_numUnfinishedWorks;
   };
   
   // In-header Implementations:
   
   inline std::size_t FixedSizeThreadPool::numWorkers() const
   {
       return m_workers.size();
   }
   
   inline bool FixedSizeThreadPool::isWorkerThread() const
   {
       const auto thisThreadId = std::this_thread::get_id();
       for(const auto& workerThread : m_workers)
       {
           if(thisThreadId == workerThread.get_id())
           {
               return true;
           }
       }
       return false;
   }
   
   }// end namespace ph
