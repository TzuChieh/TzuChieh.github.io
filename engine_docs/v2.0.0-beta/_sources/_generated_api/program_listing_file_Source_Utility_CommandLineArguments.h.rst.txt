
.. _program_listing_file_Source_Utility_CommandLineArguments.h:

Program Listing for File CommandLineArguments.h
===============================================

|exhale_lsh| :ref:`Return to documentation for file <file_Source_Utility_CommandLineArguments.h>` (``Source\Utility\CommandLineArguments.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include "Utility/string_utils.h"
   
   #include <string>
   #include <vector>
   #include <optional>
   #include <type_traits>
   
   namespace ph
   {
   
   class CommandLineArguments final
   {
   public:
       CommandLineArguments(int argc, char* argv[]);
   
       std::string getProgramName() const;
   
       bool isEmpty() const;
   
       std::string retrieveString(const std::string& defaultString = "");
   
       std::vector<std::string> retrieveStrings(std::size_t numValues);
   
       std::vector<std::string> retrieveOptionArguments(const std::string& optionPrefix);
   
       std::vector<std::string> retrieveStrings(
           const std::string& startingPrefix, 
           const std::string& endingPrefix, 
           bool shouldIncludeStart = true,
           bool shouldIncludeEnd = true);
   
       template<typename T>
       T retrieveInt(T defaultInt = 0);
   
       template<typename T>
       T retrieveFloat(T defaultFloat = 0.0f);
   
       template<typename T>
       std::optional<T> retrieve();
   
   private:
       std::string              m_programName;
       std::vector<std::string> m_arguments;
   };
   
   // In-header Implementations:
   
   inline std::string CommandLineArguments::getProgramName() const
   {
       return m_programName;
   }
   
   inline bool CommandLineArguments::isEmpty() const
   {
       return m_arguments.empty();
   }
   
   template<typename T>
   inline T CommandLineArguments::retrieveInt(T defaultInt)
   {
       static_assert(std::is_integral_v<T>,
           "expect argument type to be integer");
   
       auto optInt = retrieve<T>();
       return optInt ? *optInt : defaultInt;
   }
   
   template<typename T>
   inline T CommandLineArguments::retrieveFloat(T defaultFloat)
   {
       static_assert(std::is_floating_point_v<T>,
           "expect argument type to be floating-point");
   
       auto optFloat = retrieve<T>();
       return optFloat ? *optFloat : defaultFloat;
   }
   
   template<typename T>
   inline std::optional<T> CommandLineArguments::retrieve()
   {
       if(isEmpty())
       {
           return std::nullopt;
       }
   
       std::string argument = m_arguments.front();
       m_arguments.erase(m_arguments.begin());
   
       if constexpr(std::is_same_v<T, std::string>)
       {
           return argument;
       }
       else
       {
           static_assert(std::is_integral_v<T> || std::is_floating_point_v<T>,
               "expect argument type to be integer or floating-point");
   
           return string_utils::parse_number<T>(argument);
       }
   }
   
   }// end namespace ph
