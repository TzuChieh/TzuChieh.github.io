
.. _program_listing_file_Source_Utility_TBitFlags.h:

Program Listing for File TBitFlags.h
====================================

|exhale_lsh| :ref:`Return to documentation for file <file_Source_Utility_TBitFlags.h>` (``Source\Utility\TBitFlags.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include "Utility/traits.h"
   
   #include <type_traits>
   #include <initializer_list>
   
   namespace ph
   {
   
   template<typename Value, typename Input = Value>
   class TBitFlags final
   {
       static_assert(std::is_integral_v<Value>);
       static_assert(std::is_integral_v<Input> || std::is_enum_v<Input>);
   
       static_assert(sizeof(Value) >= sizeof(Input),
           "Input type may overflow Value type.");
   
   private:
       using FlagsSet = std::initializer_list<Input>;
   
   public:
       TBitFlags();
   
       explicit TBitFlags(const FlagsSet& flagsSet);
   
       template<typename OtherInput>
       explicit TBitFlags(const TBitFlags<Value, OtherInput>& otherFlags);
   
       TBitFlags& unionWith(const FlagsSet& flagsSet);
       TBitFlags& unionWith(const TBitFlags& flags);
   
       TBitFlags& intersectWith(const FlagsSet& flagsSet);
       
       TBitFlags& turnOn(const FlagsSet& flagsSet);
       TBitFlags& turnOff(const FlagsSet& flagsSet);
   
       bool hasNone(const FlagsSet& flagsSet) const;
   
       bool hasAny(const FlagsSet& flagsSet) const;
   
       bool hasAll(const FlagsSet& flagsSet) const;
   
       bool hasExactly(const FlagsSet& flagsSet) const;
       
       bool isEmpty() const;
   
       bool isEqual(const TBitFlags& other) const;
   
       Value get() const;
   
       // TODO: method for clear all flags
       TBitFlags& set(const FlagsSet& flagsSet);
   
       inline Input getEnum() const 
           requires CIsEnum<Input> && (sizeof(Input) >= sizeof(Value))
       {
           return static_cast<Input>(m_bits);
       }
   
   private:
       Value m_bits;
   
       static Value collectFlags(const FlagsSet& flagsSet);
   };
   
   template<CIsEnum EnumType>
   using TEnumFlags = TBitFlags<std::underlying_type_t<EnumType>, EnumType>;
   
   }// end namespace ph
   
   #define PH_DEFINE_INLINE_ENUM_FLAG_OPERATORS(EnumType)\
       static_assert(::ph::CIsEnum<EnumType>, #EnumType " must be an enum type");\
       \
       inline EnumType operator | (const EnumType lhs, const EnumType rhs)\
       {\
           return ::ph::TEnumFlags<EnumType>({lhs, rhs}).getEnum();\
       }\
       \
       inline EnumType operator & (const EnumType lhs, const EnumType rhs)\
       {\
           return ::ph::TEnumFlags<EnumType>({lhs}).intersectWith({rhs}).getEnum();\
       }
   
   #include "Utility/TBitFlags.ipp"
