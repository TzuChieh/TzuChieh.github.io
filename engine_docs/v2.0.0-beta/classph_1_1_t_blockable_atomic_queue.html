<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Photon: ph::TBlockableAtomicQueue&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Photon
   &#160;<span id="projectnumber">2.0.0-beta</span>
   </div>
   <div id="projectbrief">A Physically-based Renderer</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classph_1_1_t_blockable_atomic_queue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classph_1_1_t_blockable_atomic_queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ph::TBlockableAtomicQueue&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A multi-producer, multi-consumer, blockable version of the lock-free concurrent queue. For single-thread uses, it is a FIFO queue. For multi-thread uses, it is <em>mostly</em> a FIFO queue. Specifically, items put in by a given producer will all come out in the same order (FIFO). But there is no coordination between items from other producers&ndash;two items put in by two different producers will come out in an undefined order relative to each other (the interleaving between different streams of items from different producers is undefined, even with external synchronization). It is possible some items will starve in the queue if more items are enqueued than dequeued. Guarantees aquire-release semantics for items that are enqueued/dequeued.  
 <a href="classph_1_1_t_blockable_atomic_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_t_blockable_atomic_queue_8h_source.html">TBlockableAtomicQueue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc9f7281aa7f0df9cf81cbbf51f97d41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_blockable_atomic_queue.html#acc9f7281aa7f0df9cf81cbbf51f97d41">TBlockableAtomicQueue</a> ()</td></tr>
<tr class="separator:acc9f7281aa7f0df9cf81cbbf51f97d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66639632d5c3ed33ec014a30050b1501"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_blockable_atomic_queue.html#a66639632d5c3ed33ec014a30050b1501">TBlockableAtomicQueue</a> (std::size_t initialCapacity)</td></tr>
<tr class="separator:a66639632d5c3ed33ec014a30050b1501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e95b739e93bcb6d972107930a152fcb"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a8e95b739e93bcb6d972107930a152fcb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classph_1_1_t_blockable_atomic_queue.html#a8e95b739e93bcb6d972107930a152fcb">enqueue</a> (U &amp;&amp;item)</td></tr>
<tr class="memdesc:a8e95b739e93bcb6d972107930a152fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an item. Allocate memory if required. Basic aquire-release semantics are guaranteed. This ensures that all the effects of work done by a thread before it enqueues an item will be visible on another thread after it dequeues that item. See <a class="el" href="classph_1_1_t_blockable_atomic_queue.html#a8026b93988c2521995636e023406fbd4" title="Try to dequeue an item. While there is no contention, dequeue fails if there is no item or the memory...">tryDequeue(T*)</a> for how to ensure the item can be dequeued on another thread.  <a href="classph_1_1_t_blockable_atomic_queue.html#a8e95b739e93bcb6d972107930a152fcb">More...</a><br /></td></tr>
<tr class="separator:a8e95b739e93bcb6d972107930a152fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbf940bda83f4e8c4b8ea1a8baf7802"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:afcbf940bda83f4e8c4b8ea1a8baf7802"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classph_1_1_t_blockable_atomic_queue.html#afcbf940bda83f4e8c4b8ea1a8baf7802">tryEnqueue</a> (U &amp;&amp;item)</td></tr>
<tr class="memdesc:afcbf940bda83f4e8c4b8ea1a8baf7802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to enqueue an item. Never allocate memory.  <a href="classph_1_1_t_blockable_atomic_queue.html#afcbf940bda83f4e8c4b8ea1a8baf7802">More...</a><br /></td></tr>
<tr class="separator:afcbf940bda83f4e8c4b8ea1a8baf7802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8026b93988c2521995636e023406fbd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_blockable_atomic_queue.html#a8026b93988c2521995636e023406fbd4">tryDequeue</a> (T *out_item)</td></tr>
<tr class="memdesc:a8026b93988c2521995636e023406fbd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to dequeue an item. While there is no contention, dequeue fails if there is no item or the memory effect of enqueue is not visible. Dequeue can also fail spuriously if there is another consumer (under contention). To guarantee all enqueued items eventually got dequeued, memory effects must be made visible to the dequeuing threads.  <a href="classph_1_1_t_blockable_atomic_queue.html#a8026b93988c2521995636e023406fbd4">More...</a><br /></td></tr>
<tr class="separator:a8026b93988c2521995636e023406fbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03affc3f5eeb5480c109576c4a99aac9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_blockable_atomic_queue.html#a03affc3f5eeb5480c109576c4a99aac9">waitDequeue</a> (T *out_item)</td></tr>
<tr class="memdesc:a03affc3f5eeb5480c109576c4a99aac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the current thread until there is something to dequeue.  <a href="classph_1_1_t_blockable_atomic_queue.html#a03affc3f5eeb5480c109576c4a99aac9">More...</a><br /></td></tr>
<tr class="separator:a03affc3f5eeb5480c109576c4a99aac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65613e87fad5286dec9f0369607e48d1"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_blockable_atomic_queue.html#a65613e87fad5286dec9f0369607e48d1">estimatedSize</a> () const</td></tr>
<tr class="memdesc:a65613e87fad5286dec9f0369607e48d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximated size of the queue.  <a href="classph_1_1_t_blockable_atomic_queue.html#a65613e87fad5286dec9f0369607e48d1">More...</a><br /></td></tr>
<tr class="separator:a65613e87fad5286dec9f0369607e48d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7564649a2b1c2e1409c95926ff961665"><td class="memItemLeft" align="right" valign="top">moodycamel::BlockingConcurrentQueue&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_blockable_atomic_queue.html#a7564649a2b1c2e1409c95926ff961665">m_queue</a></td></tr>
<tr class="separator:a7564649a2b1c2e1409c95926ff961665"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class ph::TBlockableAtomicQueue&lt; T &gt;</h3>

<p>A multi-producer, multi-consumer, blockable version of the lock-free concurrent queue. For single-thread uses, it is a FIFO queue. For multi-thread uses, it is <em>mostly</em> a FIFO queue. Specifically, items put in by a given producer will all come out in the same order (FIFO). But there is no coordination between items from other producers&ndash;two items put in by two different producers will come out in an undefined order relative to each other (the interleaving between different streams of items from different producers is undefined, even with external synchronization). It is possible some items will starve in the queue if more items are enqueued than dequeued. Guarantees aquire-release semantics for items that are enqueued/dequeued. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acc9f7281aa7f0df9cf81cbbf51f97d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9f7281aa7f0df9cf81cbbf51f97d41">&#9670;&nbsp;</a></span>TBlockableAtomicQueue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classph_1_1_t_blockable_atomic_queue.html">ph::TBlockableAtomicQueue</a>&lt; T &gt;::<a class="el" href="classph_1_1_t_blockable_atomic_queue.html">TBlockableAtomicQueue</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66639632d5c3ed33ec014a30050b1501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66639632d5c3ed33ec014a30050b1501">&#9670;&nbsp;</a></span>TBlockableAtomicQueue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classph_1_1_t_blockable_atomic_queue.html">ph::TBlockableAtomicQueue</a>&lt; T &gt;::<a class="el" href="classph_1_1_t_blockable_atomic_queue.html">TBlockableAtomicQueue</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>initialCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8e95b739e93bcb6d972107930a152fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e95b739e93bcb6d972107930a152fcb">&#9670;&nbsp;</a></span>enqueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_blockable_atomic_queue.html">ph::TBlockableAtomicQueue</a>&lt; T &gt;::enqueue </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue an item. Allocate memory if required. Basic aquire-release semantics are guaranteed. This ensures that all the effects of work done by a thread before it enqueues an item will be visible on another thread after it dequeues that item. See <a class="el" href="classph_1_1_t_blockable_atomic_queue.html#a8026b93988c2521995636e023406fbd4" title="Try to dequeue an item. While there is no contention, dequeue fails if there is no item or the memory...">tryDequeue(T*)</a> for how to ensure the item can be dequeued on another thread. </p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="a65613e87fad5286dec9f0369607e48d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65613e87fad5286dec9f0369607e48d1">&#9670;&nbsp;</a></span>estimatedSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classph_1_1_t_blockable_atomic_queue.html">ph::TBlockableAtomicQueue</a>&lt; T &gt;::estimatedSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximated size of the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of items in the queue. The esimation is only accurate if all memory writes to the queue is guaranteed to be visible. Note that 0 may be returned even if the queue is, in fact, not empty. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="a8026b93988c2521995636e023406fbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8026b93988c2521995636e023406fbd4">&#9670;&nbsp;</a></span>tryDequeue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classph_1_1_t_blockable_atomic_queue.html">ph::TBlockableAtomicQueue</a>&lt; T &gt;::tryDequeue </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out_item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to dequeue an item. While there is no contention, dequeue fails if there is no item or the memory effect of enqueue is not visible. Dequeue can also fail spuriously if there is another consumer (under contention). To guarantee all enqueued items eventually got dequeued, memory effects must be made visible to the dequeuing threads. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an item is dequeued. <code>false</code> otherwise (even if the queue is not empty). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="afcbf940bda83f4e8c4b8ea1a8baf7802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbf940bda83f4e8c4b8ea1a8baf7802">&#9670;&nbsp;</a></span>tryEnqueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classph_1_1_t_blockable_atomic_queue.html">ph::TBlockableAtomicQueue</a>&lt; T &gt;::tryEnqueue </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to enqueue an item. Never allocate memory. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the item is enqueued. <code>false</code> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="a03affc3f5eeb5480c109576c4a99aac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03affc3f5eeb5480c109576c4a99aac9">&#9670;&nbsp;</a></span>waitDequeue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_blockable_atomic_queue.html">ph::TBlockableAtomicQueue</a>&lt; T &gt;::waitDequeue </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out_item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks the current thread until there is something to dequeue. </p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7564649a2b1c2e1409c95926ff961665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7564649a2b1c2e1409c95926ff961665">&#9670;&nbsp;</a></span>m_queue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">moodycamel::BlockingConcurrentQueue&lt;T&gt; <a class="el" href="classph_1_1_t_blockable_atomic_queue.html">ph::TBlockableAtomicQueue</a>&lt; T &gt;::m_queue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/dev/Photon-v2/Engine/Source/Utility/Concurrent/<a class="el" href="_t_blockable_atomic_queue_8h_source.html">TBlockableAtomicQueue.h</a></li>
<li>D:/dev/Photon-v2/Engine/Source/Utility/Concurrent/<a class="el" href="_t_blockable_atomic_queue_8ipp.html">TBlockableAtomicQueue.ipp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceph.html">ph</a></li><li class="navelem"><a class="el" href="classph_1_1_t_blockable_atomic_queue.html">TBlockableAtomicQueue</a></li>
    <li class="footer">Generated on Wed Jan 4 2023 09:33:31 for Photon by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
