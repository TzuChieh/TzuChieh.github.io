<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Photon: ph::TSPSCExecutor&lt; Work &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Photon
   &#160;<span id="projectnumber">2.0.0-beta</span>
   </div>
   <div id="projectbrief">A Physically-based Renderer</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classph_1_1_t_s_p_s_c_executor.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classph_1_1_t_s_p_s_c_executor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ph::TSPSCExecutor&lt; Work &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A single-producer, single-consumer worker thread. Ctor and dtor are not thread safe. Most of the methods are either producer thread only, or thread-safe. <a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a0d4416821710b9c3c01b9798376a9f4e" title="Start the execution of the consumer (worker thread). Whichever thread calls this method will be the p...">start()</a> must be called before adding work since it also serves as a mean to determine the producer thread. Setters for function callbacks can only be called before <a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a0d4416821710b9c3c01b9798376a9f4e" title="Start the execution of the consumer (worker thread). Whichever thread calls this method will be the p...">start()</a>. Note that if work processor is not set from ctor, <a class="el" href="classph_1_1_t_s_p_s_c_executor.html#aff408fe833f82bb136083d0e62ff8592" title="Setters for callbacks. Callbacks will execute on consumer thread.">setWorkProcessor()</a> must be called with a valid processor function.  
 <a href="classph_1_1_t_s_p_s_c_executor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_t_s_p_s_c_executor_8h_source.html">TSPSCExecutor.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structph_1_1_t_s_p_s_c_executor_1_1_custom_callable.html">CustomCallable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9f6b5ce0addb84a3de6294984c9612a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a9f6b5ce0addb84a3de6294984c9612a3">TSPSCExecutor</a> ()</td></tr>
<tr class="memdesc:a9f6b5ce0addb84a3de6294984c9612a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an executor waiting for new work.  <a href="classph_1_1_t_s_p_s_c_executor.html#a9f6b5ce0addb84a3de6294984c9612a3">More...</a><br /></td></tr>
<tr class="separator:a9f6b5ce0addb84a3de6294984c9612a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfdf73fc1054ad47c06b9370768b58f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a6dfdf73fc1054ad47c06b9370768b58f">TSPSCExecutor</a> (std::function&lt; void(const Work &amp;work)&gt; workProcessor)</td></tr>
<tr class="memdesc:a6dfdf73fc1054ad47c06b9370768b58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an executor waiting for new work.  <a href="classph_1_1_t_s_p_s_c_executor.html#a6dfdf73fc1054ad47c06b9370768b58f">More...</a><br /></td></tr>
<tr class="separator:a6dfdf73fc1054ad47c06b9370768b58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a11651bfe5596cb1acb4d5125c45fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a98a11651bfe5596cb1acb4d5125c45fb">~TSPSCExecutor</a> ()</td></tr>
<tr class="memdesc:a98a11651bfe5596cb1acb4d5125c45fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate the execution. Wait for any ongoing work to finish.  <a href="classph_1_1_t_s_p_s_c_executor.html#a98a11651bfe5596cb1acb4d5125c45fb">More...</a><br /></td></tr>
<tr class="separator:a98a11651bfe5596cb1acb4d5125c45fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4416821710b9c3c01b9798376a9f4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a0d4416821710b9c3c01b9798376a9f4e">start</a> ()</td></tr>
<tr class="memdesc:a0d4416821710b9c3c01b9798376a9f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the execution of the consumer (worker thread). Whichever thread calls this method will be the producer thread. Can only be called once in the lifetime of the executor.  <a href="classph_1_1_t_s_p_s_c_executor.html#a0d4416821710b9c3c01b9798376a9f4e">More...</a><br /></td></tr>
<tr class="separator:a0d4416821710b9c3c01b9798376a9f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348023aebd44b96af2d54e6aacda79a0"><td class="memTemplParams" colspan="2">template&lt;typename DeducedWork &gt; </td></tr>
<tr class="memitem:a348023aebd44b96af2d54e6aacda79a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a348023aebd44b96af2d54e6aacda79a0">addWork</a> (DeducedWork &amp;&amp;work)</td></tr>
<tr class="separator:a348023aebd44b96af2d54e6aacda79a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b1bd75567ccb5adcd30bdd592b42ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a75b1bd75567ccb5adcd30bdd592b42ce">waitAllWorks</a> ()</td></tr>
<tr class="memdesc:a75b1bd75567ccb5adcd30bdd592b42ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all queued works to finish. Memory effects on consumer thread are made visible to the producer thread.  <a href="classph_1_1_t_s_p_s_c_executor.html#a75b1bd75567ccb5adcd30bdd592b42ce">More...</a><br /></td></tr>
<tr class="separator:a75b1bd75567ccb5adcd30bdd592b42ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bee5c6bbc09397af7f73ef55969c93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a52bee5c6bbc09397af7f73ef55969c93">requestTermination</a> ()</td></tr>
<tr class="memdesc:a52bee5c6bbc09397af7f73ef55969c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the executor. Executor will stop processing any work as soon as possible. Any work that is already being processed will still complete. No further write operations should be performed after requesting termination. Requesting termination multiple times has the same effect.  <a href="classph_1_1_t_s_p_s_c_executor.html#a52bee5c6bbc09397af7f73ef55969c93">More...</a><br /></td></tr>
<tr class="separator:a52bee5c6bbc09397af7f73ef55969c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6ac9244a6753e4a2da159fabd10d8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#ace6ac9244a6753e4a2da159fabd10d8d">waitForTermination</a> ()</td></tr>
<tr class="memdesc:ace6ac9244a6753e4a2da159fabd10d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the executor to stop. All operations on the consumer thread will be done after this call returns. Memory effects on consumer thread are made visible to the producer thread. Cannot be called on consumer thread as this can lead to deadlock.  <a href="classph_1_1_t_s_p_s_c_executor.html#ace6ac9244a6753e4a2da159fabd10d8d">More...</a><br /></td></tr>
<tr class="separator:ace6ac9244a6753e4a2da159fabd10d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd7b547217281c83d117359584375b1"><td class="memItemLeft" align="right" valign="top">std::thread::id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a7dd7b547217281c83d117359584375b1">getId</a> () const</td></tr>
<tr class="memdesc:a7dd7b547217281c83d117359584375b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ID of the underlying thread.  <a href="classph_1_1_t_s_p_s_c_executor.html#a7dd7b547217281c83d117359584375b1">More...</a><br /></td></tr>
<tr class="separator:a7dd7b547217281c83d117359584375b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac550b3718b38d56f5684e1ea546ee7d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#ac550b3718b38d56f5684e1ea546ee7d2">hasStarted</a> () const</td></tr>
<tr class="memdesc:ac550b3718b38d56f5684e1ea546ee7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the executor has started processing works.  <a href="classph_1_1_t_s_p_s_c_executor.html#ac550b3718b38d56f5684e1ea546ee7d2">More...</a><br /></td></tr>
<tr class="separator:ac550b3718b38d56f5684e1ea546ee7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aff408fe833f82bb136083d0e62ff8592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#aff408fe833f82bb136083d0e62ff8592">setWorkProcessor</a> (std::function&lt; void(const Work &amp;work)&gt; workProcessor)</td></tr>
<tr class="memdesc:aff408fe833f82bb136083d0e62ff8592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setters for callbacks. Callbacks will execute on consumer thread.  <a href="classph_1_1_t_s_p_s_c_executor.html#aff408fe833f82bb136083d0e62ff8592">More...</a><br /></td></tr>
<tr class="separator:aff408fe833f82bb136083d0e62ff8592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3352d75b6451c17a0093f81900597d3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a3352d75b6451c17a0093f81900597d3f">setOnConsumerStart</a> (std::function&lt; void(void)&gt; onConsumerStart)</td></tr>
<tr class="separator:a3352d75b6451c17a0093f81900597d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ccd9b88d8123367b8a194ee2a0d79d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#ae1ccd9b88d8123367b8a194ee2a0d79d">setOnConsumerTerminate</a> (std::function&lt; void(void)&gt; onConsumerTerminate)</td></tr>
<tr class="separator:ae1ccd9b88d8123367b8a194ee2a0d79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a9170f200aa0cf8ec07346161ec6f0ccc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a9170f200aa0cf8ec07346161ec6f0ccc">Workload</a> = std::variant&lt; std::monostate, Work, <a class="el" href="structph_1_1_t_s_p_s_c_executor_1_1_custom_callable.html">CustomCallable</a> &gt;</td></tr>
<tr class="separator:a9170f200aa0cf8ec07346161ec6f0ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a81dbee12a3081613effc8979883d3eee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a81dbee12a3081613effc8979883d3eee">asyncExecute</a> ()</td></tr>
<tr class="memdesc:a81dbee12a3081613effc8979883d3eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the execution of the consumer thread.  <a href="classph_1_1_t_s_p_s_c_executor.html#a81dbee12a3081613effc8979883d3eee">More...</a><br /></td></tr>
<tr class="separator:a81dbee12a3081613effc8979883d3eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dc5e7367e6adf2246c0af0967dcbba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#aa6dc5e7367e6adf2246c0af0967dcbba">asyncProcessWorks</a> ()</td></tr>
<tr class="memdesc:aa6dc5e7367e6adf2246c0af0967dcbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start processing works.  <a href="classph_1_1_t_s_p_s_c_executor.html#aa6dc5e7367e6adf2246c0af0967dcbba">More...</a><br /></td></tr>
<tr class="separator:aa6dc5e7367e6adf2246c0af0967dcbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f2aab9e07c749ced9559ef8d43a543"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a11f2aab9e07c749ced9559ef8d43a543">isConsumerThread</a> () const</td></tr>
<tr class="memdesc:a11f2aab9e07c749ced9559ef8d43a543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether current thread is the worker thread.  <a href="classph_1_1_t_s_p_s_c_executor.html#a11f2aab9e07c749ced9559ef8d43a543">More...</a><br /></td></tr>
<tr class="separator:a11f2aab9e07c749ced9559ef8d43a543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed380d88fe03271a0b7c22681920c4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a6ed380d88fe03271a0b7c22681920c4e">isProducerThread</a> () const</td></tr>
<tr class="memdesc:a6ed380d88fe03271a0b7c22681920c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether current thread is the thread that calls <a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a0d4416821710b9c3c01b9798376a9f4e" title="Start the execution of the consumer (worker thread). Whichever thread calls this method will be the p...">start()</a>.  <a href="classph_1_1_t_s_p_s_c_executor.html#a6ed380d88fe03271a0b7c22681920c4e">More...</a><br /></td></tr>
<tr class="separator:a6ed380d88fe03271a0b7c22681920c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f09e3ef5de0ed0fe511c99cf90cb658"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a0f09e3ef5de0ed0fe511c99cf90cb658">terminate</a> ()</td></tr>
<tr class="memdesc:a0f09e3ef5de0ed0fe511c99cf90cb658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop processing works.  <a href="classph_1_1_t_s_p_s_c_executor.html#a0f09e3ef5de0ed0fe511c99cf90cb658">More...</a><br /></td></tr>
<tr class="separator:a0f09e3ef5de0ed0fe511c99cf90cb658"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7a477abe87c4e70773024dc7572fd550"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classph_1_1_initially_paused_thread.html">InitiallyPausedThread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a7a477abe87c4e70773024dc7572fd550">m_thread</a></td></tr>
<tr class="separator:a7a477abe87c4e70773024dc7572fd550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ac04ee47ded33d3dc12508ca384466"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classph_1_1_t_blockable_atomic_queue.html">TBlockableAtomicQueue</a>&lt; <a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a9170f200aa0cf8ec07346161ec6f0ccc">Workload</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#af4ac04ee47ded33d3dc12508ca384466">m_workloadQueue</a></td></tr>
<tr class="separator:af4ac04ee47ded33d3dc12508ca384466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd62cb7c87864c15e840524149099c9a"><td class="memItemLeft" align="right" valign="top">std::atomic_flag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#acd62cb7c87864c15e840524149099c9a">m_isTerminationRequested</a></td></tr>
<tr class="separator:acd62cb7c87864c15e840524149099c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcf94aaf48ecbdae8612c6b1568e713"><td class="memItemLeft" align="right" valign="top">std::atomic_flag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a6bcf94aaf48ecbdae8612c6b1568e713">m_isTerminated</a></td></tr>
<tr class="separator:a6bcf94aaf48ecbdae8612c6b1568e713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324d784cc5b6c72685512b61b63aaa99"><td class="memItemLeft" align="right" valign="top">std::thread::id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a324d784cc5b6c72685512b61b63aaa99">m_producerThreadId</a></td></tr>
<tr class="separator:a324d784cc5b6c72685512b61b63aaa99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffe030dbbd83e9747eecf47d69c0bac"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(const Work &amp;work)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a6ffe030dbbd83e9747eecf47d69c0bac">m_workProcessor</a></td></tr>
<tr class="separator:a6ffe030dbbd83e9747eecf47d69c0bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c487dcaef22e3da8df1da0744e52c21"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(void)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a5c487dcaef22e3da8df1da0744e52c21">m_onConsumerStart</a></td></tr>
<tr class="separator:a5c487dcaef22e3da8df1da0744e52c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a820d48875284ee4284dd93d08b2341"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(void)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a7a820d48875284ee4284dd93d08b2341">m_onConsumerTerminate</a></td></tr>
<tr class="separator:a7a820d48875284ee4284dd93d08b2341"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Work&gt;<br />
class ph::TSPSCExecutor&lt; Work &gt;</h3>

<p>A single-producer, single-consumer worker thread. Ctor and dtor are not thread safe. Most of the methods are either producer thread only, or thread-safe. <a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a0d4416821710b9c3c01b9798376a9f4e" title="Start the execution of the consumer (worker thread). Whichever thread calls this method will be the p...">start()</a> must be called before adding work since it also serves as a mean to determine the producer thread. Setters for function callbacks can only be called before <a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a0d4416821710b9c3c01b9798376a9f4e" title="Start the execution of the consumer (worker thread). Whichever thread calls this method will be the p...">start()</a>. Note that if work processor is not set from ctor, <a class="el" href="classph_1_1_t_s_p_s_c_executor.html#aff408fe833f82bb136083d0e62ff8592" title="Setters for callbacks. Callbacks will execute on consumer thread.">setWorkProcessor()</a> must be called with a valid processor function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Work</td><td>Type of the work to be processed. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9170f200aa0cf8ec07346161ec6f0ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9170f200aa0cf8ec07346161ec6f0ccc">&#9670;&nbsp;</a></span>Workload</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::<a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a9170f200aa0cf8ec07346161ec6f0ccc">Workload</a> =  std::variant&lt; std::monostate, Work, <a class="el" href="structph_1_1_t_s_p_s_c_executor_1_1_custom_callable.html">CustomCallable</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9f6b5ce0addb84a3de6294984c9612a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6b5ce0addb84a3de6294984c9612a3">&#9670;&nbsp;</a></span>TSPSCExecutor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::<a class="el" href="classph_1_1_t_s_p_s_c_executor.html">TSPSCExecutor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an executor waiting for new work. </p>

</div>
</div>
<a id="a6dfdf73fc1054ad47c06b9370768b58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfdf73fc1054ad47c06b9370768b58f">&#9670;&nbsp;</a></span>TSPSCExecutor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::<a class="el" href="classph_1_1_t_s_p_s_c_executor.html">TSPSCExecutor</a> </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const Work &amp;work)&gt;&#160;</td>
          <td class="paramname"><em>workProcessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an executor waiting for new work. </p>

</div>
</div>
<a id="a98a11651bfe5596cb1acb4d5125c45fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a11651bfe5596cb1acb4d5125c45fb">&#9670;&nbsp;</a></span>~TSPSCExecutor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::~<a class="el" href="classph_1_1_t_s_p_s_c_executor.html">TSPSCExecutor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Terminate the execution. Wait for any ongoing work to finish. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a348023aebd44b96af2d54e6aacda79a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348023aebd44b96af2d54e6aacda79a0">&#9670;&nbsp;</a></span>addWork()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<div class="memtemplate">
template&lt;typename DeducedWork &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::addWork </td>
          <td>(</td>
          <td class="paramtype">DeducedWork &amp;&amp;&#160;</td>
          <td class="paramname"><em>work</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Basic aquire-release semantics are guaranteed. This ensures that all the effects of work done by the producer thread before it enqueues a work will be visible on the consumer thread after it dequeues that work. </p>

</div>
</div>
<a id="a81dbee12a3081613effc8979883d3eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81dbee12a3081613effc8979883d3eee">&#9670;&nbsp;</a></span>asyncExecute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::asyncExecute</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the execution of the consumer thread. </p>
<dl class="section note"><dt>Note</dt><dd>Producer thread only. </dd></dl>

</div>
</div>
<a id="aa6dc5e7367e6adf2246c0af0967dcbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6dc5e7367e6adf2246c0af0967dcbba">&#9670;&nbsp;</a></span>asyncProcessWorks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::asyncProcessWorks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start processing works. </p>
<dl class="section note"><dt>Note</dt><dd>Producer thread only. </dd></dl>

</div>
</div>
<a id="a7dd7b547217281c83d117359584375b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd7b547217281c83d117359584375b1">&#9670;&nbsp;</a></span>getId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::thread::id <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::getId</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get ID of the underlying thread. </p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="ac550b3718b38d56f5684e1ea546ee7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac550b3718b38d56f5684e1ea546ee7d2">&#9670;&nbsp;</a></span>hasStarted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::hasStarted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the executor has started processing works. </p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="a11f2aab9e07c749ced9559ef8d43a543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f2aab9e07c749ced9559ef8d43a543">&#9670;&nbsp;</a></span>isConsumerThread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::isConsumerThread</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether current thread is the worker thread. </p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="a6ed380d88fe03271a0b7c22681920c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed380d88fe03271a0b7c22681920c4e">&#9670;&nbsp;</a></span>isProducerThread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::isProducerThread</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether current thread is the thread that calls <a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a0d4416821710b9c3c01b9798376a9f4e" title="Start the execution of the consumer (worker thread). Whichever thread calls this method will be the p...">start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="a52bee5c6bbc09397af7f73ef55969c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bee5c6bbc09397af7f73ef55969c93">&#9670;&nbsp;</a></span>requestTermination()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::requestTermination</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop the executor. Executor will stop processing any work as soon as possible. Any work that is already being processed will still complete. No further write operations should be performed after requesting termination. Requesting termination multiple times has the same effect. </p>
<dl class="section note"><dt>Note</dt><dd>Producer thread only. </dd></dl>

</div>
</div>
<a id="a3352d75b6451c17a0093f81900597d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3352d75b6451c17a0093f81900597d3f">&#9670;&nbsp;</a></span>setOnConsumerStart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::setOnConsumerStart </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(void)&gt;&#160;</td>
          <td class="paramname"><em>onConsumerStart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1ccd9b88d8123367b8a194ee2a0d79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ccd9b88d8123367b8a194ee2a0d79d">&#9670;&nbsp;</a></span>setOnConsumerTerminate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::setOnConsumerTerminate </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(void)&gt;&#160;</td>
          <td class="paramname"><em>onConsumerTerminate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff408fe833f82bb136083d0e62ff8592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff408fe833f82bb136083d0e62ff8592">&#9670;&nbsp;</a></span>setWorkProcessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::setWorkProcessor </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const Work &amp;work)&gt;&#160;</td>
          <td class="paramname"><em>workProcessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setters for callbacks. Callbacks will execute on consumer thread. </p>
<dl class="section note"><dt>Note</dt><dd>Can only be set before <a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a0d4416821710b9c3c01b9798376a9f4e" title="Start the execution of the consumer (worker thread). Whichever thread calls this method will be the p...">start()</a>. </dd></dl>

</div>
</div>
<a id="a0d4416821710b9c3c01b9798376a9f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4416821710b9c3c01b9798376a9f4e">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the execution of the consumer (worker thread). Whichever thread calls this method will be the producer thread. Can only be called once in the lifetime of the executor. </p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="a0f09e3ef5de0ed0fe511c99cf90cb658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f09e3ef5de0ed0fe511c99cf90cb658">&#9670;&nbsp;</a></span>terminate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::terminate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop processing works. </p>

</div>
</div>
<a id="a75b1bd75567ccb5adcd30bdd592b42ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b1bd75567ccb5adcd30bdd592b42ce">&#9670;&nbsp;</a></span>waitAllWorks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::waitAllWorks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for all queued works to finish. Memory effects on consumer thread are made visible to the producer thread. </p>
<dl class="section note"><dt>Note</dt><dd>Producer thread only. </dd></dl>

</div>
</div>
<a id="ace6ac9244a6753e4a2da159fabd10d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6ac9244a6753e4a2da159fabd10d8d">&#9670;&nbsp;</a></span>waitForTermination()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::waitForTermination</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for the executor to stop. All operations on the consumer thread will be done after this call returns. Memory effects on consumer thread are made visible to the producer thread. Cannot be called on consumer thread as this can lead to deadlock. </p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6bcf94aaf48ecbdae8612c6b1568e713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bcf94aaf48ecbdae8612c6b1568e713">&#9670;&nbsp;</a></span>m_isTerminated</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic_flag <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::m_isTerminated</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acd62cb7c87864c15e840524149099c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd62cb7c87864c15e840524149099c9a">&#9670;&nbsp;</a></span>m_isTerminationRequested</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic_flag <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::m_isTerminationRequested</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c487dcaef22e3da8df1da0744e52c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c487dcaef22e3da8df1da0744e52c21">&#9670;&nbsp;</a></span>m_onConsumerStart</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(void)&gt; <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::m_onConsumerStart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a820d48875284ee4284dd93d08b2341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a820d48875284ee4284dd93d08b2341">&#9670;&nbsp;</a></span>m_onConsumerTerminate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(void)&gt; <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::m_onConsumerTerminate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a324d784cc5b6c72685512b61b63aaa99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324d784cc5b6c72685512b61b63aaa99">&#9670;&nbsp;</a></span>m_producerThreadId</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::thread::id <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::m_producerThreadId</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a477abe87c4e70773024dc7572fd550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a477abe87c4e70773024dc7572fd550">&#9670;&nbsp;</a></span>m_thread</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classph_1_1_initially_paused_thread.html">InitiallyPausedThread</a> <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::m_thread</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af4ac04ee47ded33d3dc12508ca384466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ac04ee47ded33d3dc12508ca384466">&#9670;&nbsp;</a></span>m_workloadQueue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classph_1_1_t_blockable_atomic_queue.html">TBlockableAtomicQueue</a>&lt;<a class="el" href="classph_1_1_t_s_p_s_c_executor.html#a9170f200aa0cf8ec07346161ec6f0ccc">Workload</a>&gt; <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::m_workloadQueue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ffe030dbbd83e9747eecf47d69c0bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffe030dbbd83e9747eecf47d69c0bac">&#9670;&nbsp;</a></span>m_workProcessor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(const Work&amp; work)&gt; <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::m_workProcessor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/dev/Photon-v2/Engine/Source/Utility/Concurrent/<a class="el" href="_t_s_p_s_c_executor_8h_source.html">TSPSCExecutor.h</a></li>
<li>D:/dev/Photon-v2/Engine/Source/Utility/Concurrent/<a class="el" href="_t_s_p_s_c_executor_8ipp.html">TSPSCExecutor.ipp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceph.html">ph</a></li><li class="navelem"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html">TSPSCExecutor</a></li>
    <li class="footer">Generated on Wed Jan 4 2023 09:33:31 for Photon by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
