<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Photon: ph::ByteBufferInputStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Photon
   &#160;<span id="projectnumber">2.0.0-beta</span>
   </div>
   <div id="projectbrief">A Physically-based Renderer</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classph_1_1_byte_buffer_input_stream.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classph_1_1_byte_buffer_input_stream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ph::ByteBufferInputStream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An in-memory byte stream designed for I/O performance.  
 <a href="classph_1_1_byte_buffer_input_stream.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_byte_buffer_input_stream_8h_source.html">ByteBufferInputStream.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ph::ByteBufferInputStream:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classph_1_1_byte_buffer_input_stream.png" usemap="#ph::ByteBufferInputStream_map" alt=""/>
  <map id="ph::ByteBufferInputStream_map" name="ph::ByteBufferInputStream_map">
<area href="classph_1_1_i_input_stream.html" alt="ph::IInputStream" shape="rect" coords="0,56,158,80"/>
<area href="classph_1_1_i_data_stream.html" alt="ph::IDataStream" shape="rect" coords="0,0,158,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5fcaef8189f0150a872f5c0fe8f26826"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#a5fcaef8189f0150a872f5c0fe8f26826">ByteBufferInputStream</a> ()</td></tr>
<tr class="separator:a5fcaef8189f0150a872f5c0fe8f26826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d9335d36828468de94835af5dbfe9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#a24d9335d36828468de94835af5dbfe9f">ByteBufferInputStream</a> (const std::byte *srcByteBuffer, std::size_t numBytes)</td></tr>
<tr class="separator:a24d9335d36828468de94835af5dbfe9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae594edffbb347492c78ce1d4fbfad929"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#ae594edffbb347492c78ce1d4fbfad929">ByteBufferInputStream</a> (const char *srcCharBuffer, std::size_t numChars)</td></tr>
<tr class="separator:ae594edffbb347492c78ce1d4fbfad929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd969dbe5661f65a7bbe4c6a324d344"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#accd969dbe5661f65a7bbe4c6a324d344">ByteBufferInputStream</a> (const unsigned char *srcUCharBuffer, std::size_t numUChars)</td></tr>
<tr class="separator:accd969dbe5661f65a7bbe4c6a324d344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff2c79ebda3e694a46493f170ed8be3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#a3ff2c79ebda3e694a46493f170ed8be3">ByteBufferInputStream</a> (std::size_t numBytes)</td></tr>
<tr class="separator:a3ff2c79ebda3e694a46493f170ed8be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81203ec4723689526ee4e6f76cf9b5f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#a81203ec4723689526ee4e6f76cf9b5f1">ByteBufferInputStream</a> (<a class="el" href="classph_1_1_byte_buffer_input_stream.html">ByteBufferInputStream</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:a81203ec4723689526ee4e6f76cf9b5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3b1c48b2ff207a2ddfd877c8373d7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#aaa3b1c48b2ff207a2ddfd877c8373d7e">read</a> (std::size_t numBytes, std::byte *out_bytes) override</td></tr>
<tr class="memdesc:aaa3b1c48b2ff207a2ddfd877c8373d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read specific number of raw bytes in one go. The method does not return before finishing the reading process.  <a href="classph_1_1_byte_buffer_input_stream.html#aaa3b1c48b2ff207a2ddfd877c8373d7e">More...</a><br /></td></tr>
<tr class="separator:aaa3b1c48b2ff207a2ddfd877c8373d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4492e8813fca4621a0652a081597ac34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#a4492e8813fca4621a0652a081597ac34">readString</a> (std::string *out_string, char delimiter) override</td></tr>
<tr class="memdesc:a4492e8813fca4621a0652a081597ac34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a string in one go. Note the EOF is also considered a delimiter (the final one).  <a href="classph_1_1_byte_buffer_input_stream.html#a4492e8813fca4621a0652a081597ac34">More...</a><br /></td></tr>
<tr class="separator:a4492e8813fca4621a0652a081597ac34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46844aec5022752b7fca2eee8374bb54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#a46844aec5022752b7fca2eee8374bb54">seekGet</a> (std::size_t pos) override</td></tr>
<tr class="memdesc:a46844aec5022752b7fca2eee8374bb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the input position of the stream. The unit of the position is defined by the implementation.  <a href="classph_1_1_byte_buffer_input_stream.html#a46844aec5022752b7fca2eee8374bb54">More...</a><br /></td></tr>
<tr class="separator:a46844aec5022752b7fca2eee8374bb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158c89d7e05dc9a328dbae3adfce794d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#a158c89d7e05dc9a328dbae3adfce794d">tellGet</a> () override</td></tr>
<tr class="memdesc:a158c89d7e05dc9a328dbae3adfce794d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current input position of the stream. The unit of the position is defined by the implementation.  <a href="classph_1_1_byte_buffer_input_stream.html#a158c89d7e05dc9a328dbae3adfce794d">More...</a><br /></td></tr>
<tr class="separator:a158c89d7e05dc9a328dbae3adfce794d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1094704e4ca8947d08c828003122dfb4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#a1094704e4ca8947d08c828003122dfb4">operator bool</a> () const override</td></tr>
<tr class="memdesc:a1094704e4ca8947d08c828003122dfb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the stream is in a non-erroneous state.  <a href="classph_1_1_byte_buffer_input_stream.html#a1094704e4ca8947d08c828003122dfb4">More...</a><br /></td></tr>
<tr class="separator:a1094704e4ca8947d08c828003122dfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11b8290552e2c2da98fcb9e579ba3ad"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#ad11b8290552e2c2da98fcb9e579ba3ad">readSome</a> (std::size_t numBytes, std::byte *out_bytes) override</td></tr>
<tr class="memdesc:ad11b8290552e2c2da98fcb9e579ba3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read some data in the form of raw bytes. The method may return before finish reading all bytes. In such case, the method returns how many bytes were actually read.  <a href="classph_1_1_byte_buffer_input_stream.html#ad11b8290552e2c2da98fcb9e579ba3ad">More...</a><br /></td></tr>
<tr class="separator:ad11b8290552e2c2da98fcb9e579ba3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb75c64dd14f87612fbae375db94ce4f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb75c64dd14f87612fbae375db94ce4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#afb75c64dd14f87612fbae375db94ce4f">readData</a> (T *out_data)</td></tr>
<tr class="separator:afb75c64dd14f87612fbae375db94ce4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605f9c257b4aa87ce2025b075853c66a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#a605f9c257b4aa87ce2025b075853c66a">numBufferBytes</a> () const</td></tr>
<tr class="memdesc:a605f9c257b4aa87ce2025b075853c66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the underlying byte buffer.  <a href="classph_1_1_byte_buffer_input_stream.html#a605f9c257b4aa87ce2025b075853c66a">More...</a><br /></td></tr>
<tr class="separator:a605f9c257b4aa87ce2025b075853c66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc4b8d1b73079606968bf29a9078b6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#a7fc4b8d1b73079606968bf29a9078b6b">canRead</a> (std::size_t numBytes) const</td></tr>
<tr class="memdesc:a7fc4b8d1b73079606968bf29a9078b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether we can read <code>numBytes</code> of bytes from the stream.  <a href="classph_1_1_byte_buffer_input_stream.html#a7fc4b8d1b73079606968bf29a9078b6b">More...</a><br /></td></tr>
<tr class="separator:a7fc4b8d1b73079606968bf29a9078b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6c22e7bd88058de6ca0b0f325acc18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#afd6c22e7bd88058de6ca0b0f325acc18">canRead</a> () const</td></tr>
<tr class="memdesc:afd6c22e7bd88058de6ca0b0f325acc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether we can read any number (non-zero) of bytes from the stream.  <a href="classph_1_1_byte_buffer_input_stream.html#afd6c22e7bd88058de6ca0b0f325acc18">More...</a><br /></td></tr>
<tr class="separator:afd6c22e7bd88058de6ca0b0f325acc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990f844fe25935ecfa4eafb7fd38e8fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classph_1_1_byte_buffer_input_stream.html">ByteBufferInputStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#a990f844fe25935ecfa4eafb7fd38e8fe">operator=</a> (<a class="el" href="classph_1_1_byte_buffer_input_stream.html">ByteBufferInputStream</a> &amp;&amp;rhs)=default</td></tr>
<tr class="separator:a990f844fe25935ecfa4eafb7fd38e8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a09f33d06b0b1010ac0409efd6d613fe1"><td class="memItemLeft" align="right" valign="top">std::byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#a09f33d06b0b1010ac0409efd6d613fe1">byteBuffer</a> ()</td></tr>
<tr class="memdesc:a09f33d06b0b1010ac0409efd6d613fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the underlying byte buffer.  <a href="classph_1_1_byte_buffer_input_stream.html#a09f33d06b0b1010ac0409efd6d613fe1">More...</a><br /></td></tr>
<tr class="separator:a09f33d06b0b1010ac0409efd6d613fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad025d9770455e449bee467e1f61abe22"><td class="memItemLeft" align="right" valign="top">const std::byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#ad025d9770455e449bee467e1f61abe22">byteBuffer</a> () const</td></tr>
<tr class="separator:ad025d9770455e449bee467e1f61abe22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Aliased buffer accessors.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Helpers for accessing the underlying buffer using an aliased type (char or unsigned char). Note that the aliasing does not violate strict aliasing rules as it is specifically allowed by the standard to use char and unsigned char to alias any other types (in our case it is std::byte). </p>
</div></td></tr>
<tr class="memitem:a3a68e0f7bc352888ebe42c4ad0f96521"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#a3a68e0f7bc352888ebe42c4ad0f96521">charBuffer</a> ()</td></tr>
<tr class="separator:a3a68e0f7bc352888ebe42c4ad0f96521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945a57493f317b7818e4a3e29d439f76"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#a945a57493f317b7818e4a3e29d439f76">charBuffer</a> () const</td></tr>
<tr class="separator:a945a57493f317b7818e4a3e29d439f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5f174ee25c50910c8b4c2267ed05d3"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#aac5f174ee25c50910c8b4c2267ed05d3">ucharBuffer</a> ()</td></tr>
<tr class="separator:aac5f174ee25c50910c8b4c2267ed05d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6750705bc3c393aef0a8ada6a68b740c"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#a6750705bc3c393aef0a8ada6a68b740c">ucharBuffer</a> () const</td></tr>
<tr class="separator:a6750705bc3c393aef0a8ada6a68b740c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classph_1_1_i_input_stream"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classph_1_1_i_input_stream')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classph_1_1_i_input_stream.html">ph::IInputStream</a></td></tr>
<tr class="memitem:a4273ab96ff0f4cbcd0f9863c1fee5a11 inherit pub_methods_classph_1_1_i_input_stream"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_i_input_stream.html#a4273ab96ff0f4cbcd0f9863c1fee5a11">readLine</a> (std::string *out_string)</td></tr>
<tr class="memdesc:a4273ab96ff0f4cbcd0f9863c1fee5a11 inherit pub_methods_classph_1_1_i_input_stream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a line. Equivalent to calling read(std::string*, char) with '<br  />
' as the delimiter.  <a href="classph_1_1_i_input_stream.html#a4273ab96ff0f4cbcd0f9863c1fee5a11">More...</a><br /></td></tr>
<tr class="separator:a4273ab96ff0f4cbcd0f9863c1fee5a11 inherit pub_methods_classph_1_1_i_input_stream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classph_1_1_i_data_stream"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classph_1_1_i_data_stream')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classph_1_1_i_data_stream.html">ph::IDataStream</a></td></tr>
<tr class="memitem:aaae26b4cc468668cd571d8e2d8bd16ae inherit pub_methods_classph_1_1_i_data_stream"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_i_data_stream.html#aaae26b4cc468668cd571d8e2d8bd16ae">~IDataStream</a> ()=default</td></tr>
<tr class="separator:aaae26b4cc468668cd571d8e2d8bd16ae inherit pub_methods_classph_1_1_i_data_stream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50affe9244a09f14b66a242fd49b2cf0 inherit pub_methods_classph_1_1_i_data_stream"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_i_data_stream.html#a50affe9244a09f14b66a242fd49b2cf0">acquireName</a> ()</td></tr>
<tr class="memdesc:a50affe9244a09f14b66a242fd49b2cf0 inherit pub_methods_classph_1_1_i_data_stream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the stream's name. This method is not meant to be used in a high performance context, unless otherwise stated by the overridder. Stream name is not always available.  <a href="classph_1_1_i_data_stream.html#a50affe9244a09f14b66a242fd49b2cf0">More...</a><br /></td></tr>
<tr class="separator:a50affe9244a09f14b66a242fd49b2cf0 inherit pub_methods_classph_1_1_i_data_stream"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:acd84d7307c72e3332f544d98e328d659"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; std::byte[]&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#acd84d7307c72e3332f544d98e328d659">m_byteBuffer</a></td></tr>
<tr class="separator:acd84d7307c72e3332f544d98e328d659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ecf4e910c3adf0e520903d3727a6a3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#a36ecf4e910c3adf0e520903d3727a6a3">m_numBytes</a></td></tr>
<tr class="separator:a36ecf4e910c3adf0e520903d3727a6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7091b948bc29f024195cd47ebf6e9f"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_byte_buffer_input_stream.html#aae7091b948bc29f024195cd47ebf6e9f">m_readHead</a></td></tr>
<tr class="separator:aae7091b948bc29f024195cd47ebf6e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An in-memory byte stream designed for I/O performance. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5fcaef8189f0150a872f5c0fe8f26826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcaef8189f0150a872f5c0fe8f26826">&#9670;&nbsp;</a></span>ByteBufferInputStream() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ph::ByteBufferInputStream::ByteBufferInputStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24d9335d36828468de94835af5dbfe9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d9335d36828468de94835af5dbfe9f">&#9670;&nbsp;</a></span>ByteBufferInputStream() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ph::ByteBufferInputStream::ByteBufferInputStream </td>
          <td>(</td>
          <td class="paramtype">const std::byte *&#160;</td>
          <td class="paramname"><em>srcByteBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae594edffbb347492c78ce1d4fbfad929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae594edffbb347492c78ce1d4fbfad929">&#9670;&nbsp;</a></span>ByteBufferInputStream() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ph::ByteBufferInputStream::ByteBufferInputStream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>srcCharBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numChars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="accd969dbe5661f65a7bbe4c6a324d344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd969dbe5661f65a7bbe4c6a324d344">&#9670;&nbsp;</a></span>ByteBufferInputStream() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ph::ByteBufferInputStream::ByteBufferInputStream </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>srcUCharBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numUChars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ff2c79ebda3e694a46493f170ed8be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff2c79ebda3e694a46493f170ed8be3">&#9670;&nbsp;</a></span>ByteBufferInputStream() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ph::ByteBufferInputStream::ByteBufferInputStream </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81203ec4723689526ee4e6f76cf9b5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81203ec4723689526ee4e6f76cf9b5f1">&#9670;&nbsp;</a></span>ByteBufferInputStream() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ph::ByteBufferInputStream::ByteBufferInputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classph_1_1_byte_buffer_input_stream.html">ByteBufferInputStream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a09f33d06b0b1010ac0409efd6d613fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f33d06b0b1010ac0409efd6d613fe1">&#9670;&nbsp;</a></span>byteBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::byte * ph::ByteBufferInputStream::byteBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the underlying byte buffer. </p>

</div>
</div>
<a id="ad025d9770455e449bee467e1f61abe22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad025d9770455e449bee467e1f61abe22">&#9670;&nbsp;</a></span>byteBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::byte * ph::ByteBufferInputStream::byteBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd6c22e7bd88058de6ca0b0f325acc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6c22e7bd88058de6ca0b0f325acc18">&#9670;&nbsp;</a></span>canRead() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ph::ByteBufferInputStream::canRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether we can read any number (non-zero) of bytes from the stream. </p>

</div>
</div>
<a id="a7fc4b8d1b73079606968bf29a9078b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc4b8d1b73079606968bf29a9078b6b">&#9670;&nbsp;</a></span>canRead() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ph::ByteBufferInputStream::canRead </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numBytes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether we can read <code>numBytes</code> of bytes from the stream. </p>

</div>
</div>
<a id="a3a68e0f7bc352888ebe42c4ad0f96521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a68e0f7bc352888ebe42c4ad0f96521">&#9670;&nbsp;</a></span>charBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * ph::ByteBufferInputStream::charBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a945a57493f317b7818e4a3e29d439f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945a57493f317b7818e4a3e29d439f76">&#9670;&nbsp;</a></span>charBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * ph::ByteBufferInputStream::charBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a605f9c257b4aa87ce2025b075853c66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605f9c257b4aa87ce2025b075853c66a">&#9670;&nbsp;</a></span>numBufferBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ph::ByteBufferInputStream::numBufferBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the underlying byte buffer. </p>

</div>
</div>
<a id="a1094704e4ca8947d08c828003122dfb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1094704e4ca8947d08c828003122dfb4">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ph::ByteBufferInputStream::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the stream is in a non-erroneous state. </p>

<p>Implements <a class="el" href="classph_1_1_i_input_stream.html#ac3c06f5cef30fa9bc93601420076db10">ph::IInputStream</a>.</p>

</div>
</div>
<a id="a990f844fe25935ecfa4eafb7fd38e8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990f844fe25935ecfa4eafb7fd38e8fe">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classph_1_1_byte_buffer_input_stream.html">ByteBufferInputStream</a>&amp; ph::ByteBufferInputStream::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classph_1_1_byte_buffer_input_stream.html">ByteBufferInputStream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa3b1c48b2ff207a2ddfd877c8373d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3b1c48b2ff207a2ddfd877c8373d7e">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ph::ByteBufferInputStream::read </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::byte *&#160;</td>
          <td class="paramname"><em>out_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read specific number of raw bytes in one go. The method does not return before finishing the reading process. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classph_1_1_i_o_exception.html">IOException</a></td><td>If the read operation failed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classph_1_1_i_input_stream.html#a52d50a00cce8bf8db08b0609e6218382">ph::IInputStream</a>.</p>

</div>
</div>
<a id="afb75c64dd14f87612fbae375db94ce4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb75c64dd14f87612fbae375db94ce4f">&#9670;&nbsp;</a></span>readData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ph::ByteBufferInputStream::readData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad11b8290552e2c2da98fcb9e579ba3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11b8290552e2c2da98fcb9e579ba3ad">&#9670;&nbsp;</a></span>readSome()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ph::ByteBufferInputStream::readSome </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::byte *&#160;</td>
          <td class="paramname"><em>out_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read some data in the form of raw bytes. The method may return before finish reading all bytes. In such case, the method returns how many bytes were actually read. </p>
<dl class="section return"><dt>Returns</dt><dd>How many bytes were actually read. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classph_1_1_i_o_exception.html">IOException</a></td><td>If the read operation failed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classph_1_1_i_input_stream.html#ae2443ee3348bfd6dc361e1eeed893a32">ph::IInputStream</a>.</p>

</div>
</div>
<a id="a4492e8813fca4621a0652a081597ac34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4492e8813fca4621a0652a081597ac34">&#9670;&nbsp;</a></span>readString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ph::ByteBufferInputStream::readString </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>out_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a string in one go. Note the EOF is also considered a delimiter (the final one). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_string</td><td>The read string. Does not include the <code>delimiter</code>. </td></tr>
    <tr><td class="paramname">delimiter</td><td>The character that denotes the ending of a line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classph_1_1_i_o_exception.html">IOException</a></td><td>If the read operation failed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classph_1_1_i_input_stream.html#ad8a53daafc7dcabdc7da7989f1fc429d">ph::IInputStream</a>.</p>

</div>
</div>
<a id="a46844aec5022752b7fca2eee8374bb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46844aec5022752b7fca2eee8374bb54">&#9670;&nbsp;</a></span>seekGet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ph::ByteBufferInputStream::seekGet </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the input position of the stream. The unit of the position is defined by the implementation. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classph_1_1_i_o_exception.html">IOException</a></td><td>If the seeking process failed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classph_1_1_i_input_stream.html#a4bc65760be9331abdbbd97a8e3539491">ph::IInputStream</a>.</p>

</div>
</div>
<a id="a158c89d7e05dc9a328dbae3adfce794d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158c89d7e05dc9a328dbae3adfce794d">&#9670;&nbsp;</a></span>tellGet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::size_t &gt; ph::ByteBufferInputStream::tellGet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current input position of the stream. The unit of the position is defined by the implementation. </p>
<dl class="section return"><dt>Returns</dt><dd>Current input position. Empty if the position is unavailable. </dd></dl>

<p>Implements <a class="el" href="classph_1_1_i_input_stream.html#a02042f0b7983c82153062d47c9da3bf4">ph::IInputStream</a>.</p>

</div>
</div>
<a id="aac5f174ee25c50910c8b4c2267ed05d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5f174ee25c50910c8b4c2267ed05d3">&#9670;&nbsp;</a></span>ucharBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * ph::ByteBufferInputStream::ucharBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6750705bc3c393aef0a8ada6a68b740c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6750705bc3c393aef0a8ada6a68b740c">&#9670;&nbsp;</a></span>ucharBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * ph::ByteBufferInputStream::ucharBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acd84d7307c72e3332f544d98e328d659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd84d7307c72e3332f544d98e328d659">&#9670;&nbsp;</a></span>m_byteBuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;std::byte[]&gt; ph::ByteBufferInputStream::m_byteBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36ecf4e910c3adf0e520903d3727a6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ecf4e910c3adf0e520903d3727a6a3">&#9670;&nbsp;</a></span>m_numBytes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ph::ByteBufferInputStream::m_numBytes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aae7091b948bc29f024195cd47ebf6e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7091b948bc29f024195cd47ebf6e9f">&#9670;&nbsp;</a></span>m_readHead</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ph::ByteBufferInputStream::m_readHead</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/dev/Photon-v2/Engine/Source/DataIO/Stream/<a class="el" href="_byte_buffer_input_stream_8h_source.html">ByteBufferInputStream.h</a></li>
<li>D:/dev/Photon-v2/Engine/Source/DataIO/Stream/<a class="el" href="_byte_buffer_input_stream_8cpp.html">ByteBufferInputStream.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceph.html">ph</a></li><li class="navelem"><a class="el" href="classph_1_1_byte_buffer_input_stream.html">ByteBufferInputStream</a></li>
    <li class="footer">Generated on Wed Jan 4 2023 14:33:22 for Photon by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
